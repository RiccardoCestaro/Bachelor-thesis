
%**************************************************************
% Acronimi
%**************************************************************
\renewcommand{\acronymname}{Acronimi e abbreviazioni}

\newacronym[description={\glslink{apig}{Application Program Interface}}]
{api}{API}{Application Program Interface}

\newacronym[description={\glslink{artg}{Android Runtime Environment}}]
{art}{ART}{Android Runtime Environment}

\newacronym[description={\glslink{jarg}{Java Archive}}]
{jar}{JAR}{Java Archive}

\newacronym[description={\glslink{xmlg}{eXtensible Markup Language}}]
{xml}{XML}{eXtensible Markup Language}

\newacronym[description={\glslink{activitymanagerserviceg}{Activity Manager Service}}]
{ams}{AMS}{Activity Manager Service}

\newacronym[description={\glslink{ideg}{Integrated development environment}}]
{ide}{IDE}{Integrated development environment}

\newacronym[description={\glslink{useridg}{User ID}}]
{UID}{UID}{User ID}

\newacronym[description={\glslink{processidg}{Process ID}}]
{PID}{PID}{Process ID}




\newacronym[description={\glslink{jvmg}{Java Virtual Machine}}]
{jvm}{JVM}{Java Virtual Machine}

%**************************************************************
% Glossario
%**************************************************************
\renewcommand{\glossaryname}{Glossario}

\newglossaryentry{apig}
{
	name=\glslink{api}{API},
	text=Application Program Interface,
	sort=api,
	description={in informatica con il termine \emph{Application Programming Interface API} (ing. interfaccia di programmazione di un'applicazione) si indica ogni insieme di procedure disponibili al programmatore, di solito raggruppate a formare un set di strumenti specifici per l'espletamento di un determinato compito all'interno di un certo programma. La finalità è ottenere un'astrazione, di solito tra l'hardware e il programmatore o tra software a basso e quello ad alto livello semplificando così il lavoro di programmazione}
}

\newglossaryentry{artmethodg}
{
	name=\glslink{ArtMethod}{ArtMethod},
	text=ArtMethod,
	sort=ArtMethod,
	description={un \emph{ArtMethod} nel \emph{Runtime Android (ART) Environment} è la rappresentazione di un metodo Java a basso livello, durante la sua esecuzione }
}

\newglossaryentry{bytejavag}
{
	name=\glslink{BytecodeJava}{Bytecode Java},
	text=bytecode Java,
	sort=BytecodeJava,
	description={il compilatore di \emph{Java} traduce i file sorgenti in un linguaggio chiamato \emph{bytecode} che viene salvato in dei file .class. Il \emph{bytecode} è il codice che viene interpretato a runtime dall'ambiente di esecuzione ed è un linguaggio intermedio più astratto tra il linguaggio macchina e il linguaggio di programmazione }
}

\newglossaryentry{artg}
{
	name=\glslink{art}{ART},
	text=Android Runtime Environment,
	sort=AndroidRuntimeEnvironment,
	description={il \emph{Runtime Android (ART) Environment} è l'ambiente di esecuzione utilizzato dalla versione di \emph{Android Lollipop 5.0} con la particolarità di adottare una politica di compilazione a tempo di installazione }
}

\newglossaryentry{dalvikg}
{
	name=\glslink{dalvik}{Dalvik Runtime},
	text=Dalvik Runtime,
	sort=DalvikRuntime,
	description={il \emph{Dalvik Runtime} è il vecchio ambiente di esecuzione utilizzato fino a \emph{Android KitKat 4.4}. Utilizzava la classica compilazione a runtime di \emph{Java} }
}

\newglossaryentry{playstoreg}
{
    name=\glslink{PlayStore}{Google Play Store},
    text=Google Play Store,
    sort=GooglePlayStore,
    description={il \emph{Google Play Store} è lo store ufficiale di \emph{Google} disponibile sui dispositivi \emph{Android} certificati dai quali poter scaricare qualsiasi applicazione o contenuto multimediale. Al suo interno si possono trovare diverse sezioni divise per tipologia di applicazione o contenuto, quali giochi, applicazioni, film o libri  }
}

\newglossaryentry{phishingg}
{
	name=\glslink{Phishing}{Phishing},
	text=phishing,
	sort=Phishing,
	description={il \emph{phishing} è una truffa informatica attraverso la quale l'attaccante cerca di entrare in possesso di informazioni sensibili. In generale l'attaccante si finge un ente affidabile in una comunicazione digitale convicendo l'utente a condividere dati finanziari, codici di accesso o informazioni personali }
}



\newglossaryentry{jvmg}
{
	name=\glslink{jvmg}{JVM},
	text=JVM,
	sort=jvm,
	description={La \emph{JVM, Java Virtual Machine} è il componente della piattaforma Java che esegue i programmi tradotti in bytecode dopo una prima fase di compilazione. Alcuni dei linguaggi di programmazione che possono essere tradotti in bytecode sono Java, Kotlin e Scala.}
}


\newglossaryentry{jarg}
{
	name=\glslink{jar}{JAR},
	text=JAR,
	sort=jar,
	description={il file \emph{jar} o \emph{Java Archive} è un archivio di dati compresso che viene utilizzato per distribuire file contenenti \emph{bytecode} di Java. Solitamente vengono chiamati anche package e vengono associati al concetto di libreria. Ovviamente per poter interpretare il \emph{bytecode} è necessario possedere una \emph{JVM} }
}


\newglossaryentry{dexfileg}
{
	name=\glslink{dex}{Dex},
	text=dex,
	sort=dex,
	description={il file \emph{dex}, \emph{Dalvik executable}, è lo specifico \emph{bytecode} di Java utilizzato in \emph{Android}. Viene interpretato dagli ambienti di esecuzione, oppure viene precompilato a tempo di installazione }
}

\newglossaryentry{chag}
{
	name=\glslink{cha}{Class Hierarchy Analysis},
	text=Class Hierarchy Analysis,
	sort=ClassHierarchyAnalysis,
	description={la \emph{Class Hierarchy Analysis} è l'analisi statica della gerarchia di classi al fine di devirtualizzare possibili metodi per velocizzare l'esecuzione a runtime }
}

\newglossaryentry{stacktraceg}
{
	name=\glslink{stacktrace}{Stacktrace},
	text=stacktrace,
	sort=Stacktrace,
	description={ lo \emph{stacktrace} è un report dello stack in un certo momento dell'esecuzione di un programma. Viene utilizzato per informare gli sviluppatori segnalando gli errori che si verificano a runtime. Un modo per ottenere un report dello stacktrace è lanciare delle eccezioni }
}

\newglossaryentry{dalvikvmg}
{
	name=\glslink{DalvikVM}{Dalvik VM},
	text=Dalvik VM,
	sort=DalvikVM,
	description={la \emph{Dalvik virtual machine} è una macchina virtuale alternativa alla classica \emph{Java virtual machine} utilizzata per il sistema operativo \emph{Android}. Era stata creata per sfruttare al meglio la poca memoria presente nei dispositivi mobili. Da \emph{Android Lollipop 5.0} viene sostituita con il runtime \emph{ART} portando miglioramenti per i dispositivi con hardware più performante nati negli ultimi anni }
}

\newglossaryentry{xmlg}
{
	name=\glslink{xml}{XML},
	text=XML,
	sort=xml,
	description={ l'\emph{XML o eXtensible Markup Language} è un linguaggio di markup che consente di definire e controllare il significato degli elementi contenuti. Viene utilizzato per definire altri linguaggi di markup più specifici per un compito, come l'HTML }
}

\newglossaryentry{garbcollg}
{
	name=\glslink{Garbage Collector}{Garbage Collector},
	text=Garbage Collector,
	sort=GarbageCollector,
	description={ il \emph{Garbage Collector} è la modalità automatica di gestione dei rifiuti di \emph{Java} che permette al programmatore di non dover liberare spazio in memoria manualmente. Infatti il \emph{Garbage Collector} libera lo spazio di memoria puntato da variabili inutilizzate }
}

\newglossaryentry{classloaderg}
{
	name=\glslink{Class Loader}{Class Loader},
	text=ClassLoader,
	sort=ClassLoader,
	description={ il \emph{class loader} è un oggetto responsabile dell'avvio di altre classi durante l' interpretazione a runtime del \emph{bytecode} di Java }
}

\newglossaryentry{manifestg}
{
	name=\glslink{manifest}{Manifest},
	text=manifest,
	sort=manifest,
	description={ il file \emph{AndroidManifest} è un \emph{XML} contenente informazioni dettagliate riguardo l' applicazione come i suoi permessi, i suoi componenti e il suo nome. Infatti è il resposabile della sicurezza di un'applicazione   }
}

\newglossaryentry{sandboxg}
{
	name=\glslink{sandbox}{Sandbox},
	text=sandbox,
	sort=sandbox,
	description={ in informatica indica un ambiente di prova, completamente slegato dall'ambiente nativo, utilizzato per provare le applicazioni e testarne il loro comportamento. Le sandbox possono essere viste come un esempio particolare di virtualizzazione utilizzata nella sicurezza informatica }
}

\newglossaryentry{hookg}
{
	name=\glslink{hook}{Hook},
	text=hook,
	sort=hook,
	description={ gli \emph{hook} sono intercettazioni alle chiamate delle \emph{API} con delle possibili modifiche per alterarne il comportamento. L'applicazione di un \emph{hook} può essere statica, modificando precedentemente il codice, oppure dinamica, cioè applicando degli \emph{hook} a runtime. Inoltre un \emph{hook} ad alto livello è possibile applicarlo estendendo delle classi vittima e facendo l'override dei metodi, mentre un hook a basso livello lo si può applicare modificando il codice macchina }
}


\newglossaryentry{useridg}
{
	name=\glslink{UID}{UID},
	text=userID,
	sort=userID,
	description={ id univoco per l'identificazione di un pacchetto che viene assegnato all'installazione dell'applicazione. Viene utilizzato per definire lo spazio di memoria secondaria e i permessi utilizzabili dall'applicazione. Tutti i processi di un pacchetto condividono lo stesso userID   }
}

\newglossaryentry{processidg}
{
	name=\glslink{PID}{PID},
	text=processID,
	sort=processID,
	description={ id univoco per l'identificazione di un processo che viene assegnato dal sistema operativo all'avvio di un nuovo processo. Non è modificabile }
}

\newglossaryentry{activityg}
{
	name=\glslink{Activity}{Activity},
	text=activity,
	sort=Activity,
	description={ in \emph{Android} un'\emph{activity} è una singola pagina che contiene l'interfaccia utente.\\ Un' applicazione solitamente è composta da una o più activity. Tutte le \emph{activity} devono essere dichiarate nel \emph{AndroidManifest.xml} }
}

\newglossaryentry{activitymanagerserviceg}
{
	name=\glslink{ams}{AMS},
	text=Activity Manager Service,
	sort=ActivityManagerService,
	description={ in \emph{Android} l'oggetto di tipo \emph{ActivityManagerService} viene utilizzato per gestire il ciclo di vita di ogni \emph{Activity} }
}

\newglossaryentry{atg}
{
	name=\glslink{ActivityThread}{ActivityThread},
	text=ActivityThread,
	sort=ActivityThread,
	description={ in \emph{Android} l'oggetto di tipo \emph{ActivityThread} viene utilizzato per gestire il comportamento delle \emph{Activity} }
}

\newglossaryentry{rootg}
{
	name=\glslink{Root}{Root},
	text=root,
	sort=Root,
	description={ in \emph{Android} il super utente prende il nome di utente \emph{root}. Generalmente per ottenere i permessi di \emph{root} è necessaria una procedura macchinosa che dipende dal produttore del dispositivo, che permetta lo sblocco del bootloader, in modo da avviare software non ufficiale all'avvio del dispositivo. Tramite una recovery non ufficiale è poi possibile installare dei pacchetti che consentono l'accesso ai permessi di superutente }
}

\newglossaryentry{launcherg}
{
	name=\glslink{launcher}{Launcher},
	text=launcher,
	sort=launcher,
	description={ in \emph{Android} il \emph{launcher} è la pagina tramite la quale è possibile visualizzare tutte le applicazioni utente installate nel dispositivo. Ogni produttore tende a personalizzare il proprio launcher dando la possibilità all'utente di decidere la posizione delle icone e dei widget. Di solito i launcher contengono il drawer, cioè una lista di tutte le applicazioni in ordine alfabetico  }
}

\newglossaryentry{xposedg}
{
	name=\glslink{Xposed}{Xposed},
	text=Xposed,
	sort=Xposed,
	description={ \emph{Xposed} è un framework che permette di modificare le chiamate ai metodi delle API di Java e di sistema. Di solito viene utilizzato per aggiungere funzionalità al sistema operativo, oppure per modificare graficamente le applicazioni. Di norma, viste le sue potenzialità, necessita dei permessi di root. }
}

\newglossaryentry{taskg}
{
	name=\glslink{Task}{Task},
	text=task,
	sort=Task,
	description={ Un \emph{task} è un'insieme di activity con cui l'utente interagisce per il raggiungimento di uno specifico obbiettivo }
}

\newglossaryentry{serviceg}
{
	name=\glslink{Service}{Service},
	text=Service,
	sort=Service,
	description={ Un \emph{service} è un componente di un'applicazione che può effettuare lunghe operazioni in background. Non prevede alcun tipo di interfaccia grafica infatti un \emph{service} non deve avere alcuna interazione con l'utente. I componenti \emph{service} devono essere tutti dichiarati nel file AndroidManifest.xml }
}

\newglossaryentry{ideg}
{
	name=\glslink{ide}{IDE},
	text=IDE,
	sort=ide,
	description={ un \emph{integrated development environment} è un ambiente di sviluppo integrato che supporta i programmatori nello sviluppo del codice sorgente di un programma. L'\emph{IDE} segnala errori di sintassi direttamente in fase di scrittura e contiene inoltre una serie di strumenti e funzionalità di supporto alla fase di sviluppo e debugging }
}

\newglossaryentry{intentg}
{
	name=\glslink{intent}{Intent},
	text=intent,
	sort=intent,
	description={ un \emph{intent} è un meccanismo che consente gli sviluppatori di far comunicare più componenti tra di loro. Quindi un componente richiede una funzionalità che viene implementata in un altro componente. Può essere utilizzato anche tra pacchetti diversi   }
}

\newglossaryentry{callbackg}
{
	name=\glslink{callback}{Callback},
	text=callback,
	sort=callback,
	description={ una funzione di \emph{callback} è una funzione o un blocco di codice che viene passato come parametro ad un'altra funzione  }
}

\newglossaryentry{contentproviderg}
{
	name=\glslink{contentprovider}{Content Provider},
	text=content provider,
	sort=contentprovider,
	description={ un \emph{content provider} è un componente che permette di leggere e scrivere dei dati disponibili in una certa sorgente inviando delle chiamate ad un indirizzo univoco. I comandi utilizzati per scrivere e leggere nella sorgente corrispondono a quelli utilizzati nei database (CRUD) }
}

\newglossaryentry{broadcastreceiverg}
{
	name=\glslink{broadcastreceiver}{Broadcast Receiver},
	text=broadcast receiver,
	sort=broadcastreceiver,
	description={ un \emph{broadcast provider} è un componente capace di interagire con dei messaggi inviati al sistema operativo, in modo da capire quando è avvenuto un certo evento come l'arrivo di un SMS }
}